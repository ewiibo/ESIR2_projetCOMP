package org.xtext.generator

	
class Traducteurx {
	TroisAdd code3
	TableSymbole ts
	
	
	def Traducteurx(TroisAdd code3, TableSymbole ts){
		this.code3 = code3
		this.ts = ts
	}
	def translate(String className){
		var str = ""
		for(key : code3.code3AddressH.keySet){
			var func = ts.tableSymbFunc.get(key)
			for (v : func.varIn)
				func.vars.remove(v)
			str += 
				'''
				BinTree «func.name» («FOR read: func.varIn SEPARATOR ", "»BinTree «read»«ENDFOR»){
					ArrayList<String> varIn = new ArrayList<>(); «FOR vi : func.varIn»varIn.add(«vi»);«ENDFOR»
					String vars[] = {«FOR vi : func.vars SEPARATOR ","»«vi»«ENDFOR»};   
					HashMap<String, BinTree> variables = new HashMap<>();
					
					//Changer ca pour mettre a jour les variables passées en parametres au lieu de les laissé à Null
					for(String var : vars) variables.put(var,null);
					
				
				«FOR code : code3.code3AddressH.get(key)»«translate3Add(code)»
				«ENDFOR»
				'''+"}\n"
		}
		return'''
		package test;
		
		public class «className»{
			«str»
			
		}
		'''
	}
	
	def translate3Add(Quadruplet<OpImpl> code){
		
		if (code.operateur.operator == Op.Func)
			return '''''';
		if (code.operateur.operator == Op.Read)
			return '''''';
		if (code.operateur.operator == Op.Nop)
			return translateNop(code);
		if(code.operateur.operator == Op.Write)
			return translateWrite(code)
		
	}
	
	def translateNop(Quadruplet<OpImpl> code){
		return "libwh.nop();";
	}
	def translateWrite(Quadruplet<OpImpl> code){
		''''''
	}
	def translateAff(Quadruplet<OpImpl> code){
		return ""
	}
	
	
}